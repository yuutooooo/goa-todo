// Code generated by goa v3.20.0, DO NOT EDIT.
//
// memo HTTP client CLI support package
//
// Command:
// $ goa gen backend/design

package client

import (
	memo "backend/gen/memo"
	"encoding/json"
	"fmt"
	"strconv"
	"unicode/utf8"

	goa "goa.design/goa/v3/pkg"
)

// BuildCreatePayload builds the payload for the memo create endpoint from CLI
// flags.
func BuildCreatePayload(memoCreateBody string, memoCreateUserID string, memoCreateTodoID string) (*memo.CreatePayload, error) {
	var err error
	var body CreateRequestBody
	{
		err = json.Unmarshal([]byte(memoCreateBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"content\": \"64x\"\n   }'")
		}
		if utf8.RuneCountInString(body.Content) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.content", body.Content, utf8.RuneCountInString(body.Content), 3, true))
		}
		if err != nil {
			return nil, err
		}
	}
	var userID int
	{
		var v int64
		v, err = strconv.ParseInt(memoCreateUserID, 10, strconv.IntSize)
		userID = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for userID, must be INT")
		}
	}
	var todoID int
	{
		var v int64
		v, err = strconv.ParseInt(memoCreateTodoID, 10, strconv.IntSize)
		todoID = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for todoID, must be INT")
		}
	}
	v := &memo.CreatePayload{
		Content: body.Content,
	}
	v.UserID = userID
	v.TodoID = todoID

	return v, nil
}

// BuildListPayload builds the payload for the memo list endpoint from CLI
// flags.
func BuildListPayload(memoListUserID string, memoListTodoID string) (*memo.ListPayload, error) {
	var err error
	var userID int
	{
		var v int64
		v, err = strconv.ParseInt(memoListUserID, 10, strconv.IntSize)
		userID = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for userID, must be INT")
		}
	}
	var todoID int
	{
		var v int64
		v, err = strconv.ParseInt(memoListTodoID, 10, strconv.IntSize)
		todoID = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for todoID, must be INT")
		}
	}
	v := &memo.ListPayload{}
	v.UserID = userID
	v.TodoID = todoID

	return v, nil
}

// BuildGetPayload builds the payload for the memo get endpoint from CLI flags.
func BuildGetPayload(memoGetUserID string, memoGetTodoID string, memoGetMemoID string) (*memo.GetPayload, error) {
	var err error
	var userID int
	{
		var v int64
		v, err = strconv.ParseInt(memoGetUserID, 10, strconv.IntSize)
		userID = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for userID, must be INT")
		}
	}
	var todoID int
	{
		var v int64
		v, err = strconv.ParseInt(memoGetTodoID, 10, strconv.IntSize)
		todoID = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for todoID, must be INT")
		}
	}
	var memoID int
	{
		var v int64
		v, err = strconv.ParseInt(memoGetMemoID, 10, strconv.IntSize)
		memoID = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for memoID, must be INT")
		}
	}
	v := &memo.GetPayload{}
	v.UserID = userID
	v.TodoID = todoID
	v.MemoID = memoID

	return v, nil
}

// BuildUpdatePayload builds the payload for the memo update endpoint from CLI
// flags.
func BuildUpdatePayload(memoUpdateBody string, memoUpdateUserID string, memoUpdateTodoID string, memoUpdateMemoID string) (*memo.UpdatePayload, error) {
	var err error
	var body UpdateRequestBody
	{
		err = json.Unmarshal([]byte(memoUpdateBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"content\": \"hp6\"\n   }'")
		}
		if utf8.RuneCountInString(body.Content) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.content", body.Content, utf8.RuneCountInString(body.Content), 3, true))
		}
		if err != nil {
			return nil, err
		}
	}
	var userID int
	{
		var v int64
		v, err = strconv.ParseInt(memoUpdateUserID, 10, strconv.IntSize)
		userID = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for userID, must be INT")
		}
	}
	var todoID int
	{
		var v int64
		v, err = strconv.ParseInt(memoUpdateTodoID, 10, strconv.IntSize)
		todoID = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for todoID, must be INT")
		}
	}
	var memoID int
	{
		var v int64
		v, err = strconv.ParseInt(memoUpdateMemoID, 10, strconv.IntSize)
		memoID = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for memoID, must be INT")
		}
	}
	v := &memo.UpdatePayload{
		Content: body.Content,
	}
	v.UserID = userID
	v.TodoID = todoID
	v.MemoID = memoID

	return v, nil
}

// BuildDeletePayload builds the payload for the memo delete endpoint from CLI
// flags.
func BuildDeletePayload(memoDeleteUserID string, memoDeleteTodoID string, memoDeleteMemoID string) (*memo.DeletePayload, error) {
	var err error
	var userID int
	{
		var v int64
		v, err = strconv.ParseInt(memoDeleteUserID, 10, strconv.IntSize)
		userID = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for userID, must be INT")
		}
	}
	var todoID int
	{
		var v int64
		v, err = strconv.ParseInt(memoDeleteTodoID, 10, strconv.IntSize)
		todoID = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for todoID, must be INT")
		}
	}
	var memoID int
	{
		var v int64
		v, err = strconv.ParseInt(memoDeleteMemoID, 10, strconv.IntSize)
		memoID = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for memoID, must be INT")
		}
	}
	v := &memo.DeletePayload{}
	v.UserID = userID
	v.TodoID = todoID
	v.MemoID = memoID

	return v, nil
}
